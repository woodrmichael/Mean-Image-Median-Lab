<meta charset="utf-8" lang="en">            <style class="fallback">body{visibility:hidden;}</style>
<!---


                       DOWNLOAD AND OPEN IN A BROWSER
                          TO SEE PROPER FORMATTING


--->
**Lab 3: Mean Image Median**
    Username: woodm
    Date: 02-07-2024
    Course: CSC1120
    Submitted to: Dr. Chris Taylor


!!! METRIcS: Instructor Feedback
    | Earned | Possible | Criteria                                         |
    | ------ | -------- | ------------------------------------------------ |
    |   60   |    60    | Technical quality (see point deductions in code) |
    |   15   |    15    | Intermediate commits                             |
    |    5   |     5    | UI is not confusing to operate                   |
    |   10   |    10    | Coding standard compliance and program clarity   |
    |   10   |    10    | Following submission instructions                |

    [Nicely Done](https://msoe.us/taylor/Nice)

# Controller.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 3 - Mean Image Median
 * Name: Michael Wood
 * Created: 2/1/2024
 */
package woodm;

import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.FileChooser;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

/**
 * The Controller class is used to control the layout.fxml GUI
 */
public class Controller {
    @FXML
    private HBox imageContainer;
    @FXML
    private ImageView finalImageView;
    @FXML
    private Label messageBox;
    private Image finalImage;
~~~~ Java highlight
    private final ArrayList&lt&#xFEFF;Image> inputImages;
~~~~
!!! MINUS: Prefer interface references
    The [Coding Standard](https://csse.msoe.us/csc1120/codingstandard) requires
    the following:
    <blockquote>When available, interface references are preferred over class
    references.</blockquote>
    By making use of the interface reference you are targeting a interface
    rather than committing to a specific implementation.  Doing so makes your
    code easier to modify in the future since swapping out the implementation
    only requires a change where the object is created.

~~~~ Java
    private final FileChooser fileChooser;

    /**
     * Creates a new Controller with a FileChooser that has ExtensionFilters
     * and an ArrayList of Images
     */
    public Controller() {
        this.fileChooser = new FileChooser();
        fileChooser.getExtensionFilters().add(
                new FileChooser.ExtensionFilter("Image Files", "*.png", "*.jpg", "*.ppm"));
        this.inputImages = new ArrayList&lt&#xFEFF;>();
    }

    /**
     * Adds the images the user wants to the scroll pane at the top of the window
     * with a remove button below to remove the image if needed
     */
    @FXML
    private void inputImages() {
        this.messageBox.setText("");
        final int inputImageWidth = 240;
        final int inputImageHeight = 170;
        try {
            List&lt&#xFEFF;File> imageFiles = this.fileChooser.showOpenMultipleDialog(null);
            for (File imageFile : imageFiles) {
                Path imagePath = imageFile.toPath();
                Image image = MeanImageMedian.readImage(imagePath);
                this.inputImages.addFirst(image);
                VBox imagePanel = new VBox();
                this.imageContainer.getChildren().addFirst(imagePanel);
                ImageView imageView = new ImageView(image);
                imageView.setFitWidth(inputImageWidth);
                imageView.setFitHeight(inputImageHeight);
                HBox bottomContainer = new HBox();
                Button removeButton = new Button("Remove");
                removeButton.setOnAction(this::removeImage);
                Label dimensionLabel = new Label(imagePath.getFileName() + "\nDimensions: " +
                        (int) image.getWidth() + " x " + (int) image.getHeight());
                bottomContainer.getChildren().addAll(removeButton, dimensionLabel);
                imagePanel.getChildren().addAll(imageView, bottomContainer);
            }
        } catch(IOException | IllegalArgumentException e) {
            this.messageBox.setText(e.getMessage());
~~~~ Java highlight
        } catch(NullPointerException e) {
            this.messageBox.setText("Please pick at least one image file");
        }
~~~~
!!! MINUS: -1 Check for null instead of catching the `NullPointerException`
    You should check to make sure that each reference is not `null`
    prior to calling calling a method on it instead of catching the exception
    that is thrown if the call is made.

    Exceptions provide a mechanism to encounter a problem in one part of
    the code, e.g., in reusable library method like `Scanner.nextInt()`,
    and then handle it in a completely different part of the code, e.g.,
    your controller class where you can then interact with the user. If you
    can easily avoid cause an exception to be thrown, that is better.

    In nearly all cases you should not catch `NullPointerException`s.

    Here you probably don't want to even bother the user with an alert
    if they cancel the file dialog.

~~~~ Java
    }

    /**
     * Saves the image to a file at the users requested location
     */
    @FXML
    private void save() {
        this.messageBox.setText("");
        try {
            Path imagePath = this.fileChooser.showSaveDialog(null).toPath();
            MeanImageMedian.writeImage(imagePath, this.finalImage);
            this.messageBox.setText("Successfully saved file to: " + imagePath.toAbsolutePath());
        } catch(IOException | IllegalArgumentException e) {
            this.messageBox.setText(e.getMessage());
        } catch(NullPointerException e) {
            this.messageBox.setText("Please select a image file to save your image to");
        }
    }

    /**
     * Calculates the mean or the median of the input images
     * and displays the mean image at the bottom of the window
     * @param actionEvent an ActionEvent object used to get the source of the event
     */
    @FXML
    private void calculateMeanMedian(ActionEvent actionEvent) {
        this.messageBox.setText("");
        Button button = (Button) actionEvent.getSource();
        Image[] inputImages = new Image[this.inputImages.size()];
        try {
            if(button.getText().equals("Mean")) {
                this.finalImage =
                        MeanImageMedian.calculateMeanImage(this.inputImages.toArray(inputImages));
            } else {
                this.finalImage =
                        MeanImageMedian.calculateMedianImage(this.inputImages.toArray(inputImages));
            }
        } catch(IllegalArgumentException e) {
            this.messageBox.setText(e.getMessage());
        }
        this.finalImageView.setImage(this.finalImage);
    }

    /**
     * Removes the desired image from the input images
     * @param actionEvent an ActionEvent object used to get the source of the event
     */
    private void removeImage(ActionEvent actionEvent) {
        this.messageBox.setText("");
        Button removeButton = (Button) actionEvent.getSource();
        VBox imagePanel = (VBox) removeButton.getParent().getParent();
        this.inputImages.remove(this.imageContainer.getChildren().indexOf(imagePanel));
        this.imageContainer.getChildren().remove(imagePanel);
    }

    /**
     * Transforms the colors of each pixel to either darker or lighter
     * depending on which button was pressed
     * @param actionEvent an ActionEvent object used to get the source of the event
     */
    @FXML
    private void transformColorChange(ActionEvent actionEvent) {
        this.messageBox.setText("");
        Image[] inputImages = new Image[this.inputImages.size()];
        Button button = (Button) actionEvent.getSource();
        String transformation = button.getText();
        try {
            this.finalImage =
                    MeanImageMedian.transformColorChange(
                            this.inputImages.toArray(inputImages), transformation);
        } catch(IllegalArgumentException e) {
            this.messageBox.setText(e.getMessage());
        }
        this.finalImageView.setImage(this.finalImage);
    }

    /**
     * Clears all the text fields, input images, and the final image displayed at the bottom
     */
    @FXML
    private void clear() {
        this.messageBox.setText("");
        this.imageContainer.getChildren().clear();
        this.inputImages.clear();
        this.finalImageView.setImage(null);
        this.finalImage = null;
    }
}

~~~~

# Lab3.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 3 - Mean Image Median
 * Name: Michael Wood
 * Created: 1/31/2024
 */
package woodm;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;

import java.io.IOException;

/**
 * Creates an interactive GUI to calculate the mean or median on a set of images
 */
public class Lab3 extends Application {
    @Override
    public void start(Stage stage) {
        try {
            Parent pane = FXMLLoader.load(getClass().getResource("layout.fxml"));
            stage.setScene(new Scene(pane));
            stage.setTitle("Mean Image Median");
            stage.setResizable(false);
            stage.show();
        } catch (IOException e) {
            System.out.println("There was an error reading the FXML file, please try again");
        }
    }

    public static void main(String[] args) {
        Application.launch(args);
    }
}

~~~~

# MeanImageMedian.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 1 - Mean Image Median Lab
 * Name: Michael Wood
 * Created: 1/18/2024
 */
package woodm;

import javafx.scene.image.Image;
import javafx.scene.image.WritableImage;
import javafx.embed.swing.SwingFXUtils;

import javax.imageio.ImageIO;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Scanner;

/**
 * The MeanImageMedian class offers multiple methods to generate mean and median images
 * of 2 or more images.
 */
public class MeanImageMedian {
    
    /**
     * Maximum color value
     */
    public static final int MAX_COLOR = 255;
    private static final int MINIMUM_FILE_LENGTH = 5;

    /**
     * Calculates the median of all the images passed to the method.
     * &lt&#xFEFF;br />
     * Each pixel in the output image consists is calculated as the median
     * red, green, and blue components of the input images at the same location.
     * @param inputImages Images to be used as input
     * @return An image containing the median color value for each pixel in the input images
     *
     * @throws IllegalArgumentException Thrown if inputImages or any element of inputImages is null,
     * the length of the array is less than two, or  if any of the input images differ in size.
     */
    public static Image calculateMedianImage(Image[] inputImages) {
        checkInputImages(inputImages);
        int width = (int) inputImages[0].getWidth();
        int height = (int) inputImages[0].getHeight();
        WritableImage image = new WritableImage(width, height);
        for(int row = 0; row &lt&#xFEFF; width; row++) {
            for(int col = 0; col &lt&#xFEFF; height; col++) {
                int[][] arr = getARGBArrays(inputImages, row, col);
                int a = calculateMedian(arr[0]);
                int r = calculateMedian(arr[1]);
                int g = calculateMedian(arr[2]);
                int b = calculateMedian(arr[3]);
                image.getPixelWriter().setArgb(row, col, argbToInt(a, r, g, b));
            }
        }
        return image;
    }

    /**
     * Calculates the mean of all the images passed to the method.
     * &lt&#xFEFF;br />
     * Each pixel in the output image consists is calculated as the average of the
     * red, green, and blue components of the input images at the same location.
     * @param inputImages Images to be used as input
     * @return An image containing the mean color value for each pixel in the input images
     *
     * @throws IllegalArgumentException Thrown if inputImages or any element of inputImages is null,
     * the length of the array is less than two, or  if any of the input images differ in size.
     */
    public static Image calculateMeanImage(Image[] inputImages) {
        checkInputImages(inputImages);
        int width = (int) inputImages[0].getWidth();
        int height = (int) inputImages[0].getHeight();
        WritableImage image = new WritableImage(width, height);
        for(int row = 0; row &lt&#xFEFF; width; row++) {
            for(int col = 0; col &lt&#xFEFF; height; col++) {
                int a = 0;
                int r = 0;
                int g = 0;
                int b = 0;
                for (Image inputImage : inputImages) {
                    int argb = inputImage.getPixelReader().getArgb(row, col);
                    a += argbToAlpha(argb);
                    r += argbToRed(argb);
                    g += argbToGreen(argb);
                    b += argbToBlue(argb);
                }
                a = (int) Math.round(((double) a) / inputImages.length);
                r = (int) Math.round(((double) r) / inputImages.length);
                g = (int) Math.round(((double) g) / inputImages.length);
                b = (int) Math.round(((double) b) / inputImages.length);
                image.getPixelWriter().setArgb(row, col, argbToInt(a, r, g, b));
            }
        }
        return image;
    }
    /**
     * Calculates the darker or lighter image of all the images passed to the method.
     * &lt&#xFEFF;br />
     * Each pixel in the output image consists is calculated as either the lighter or darker
     * red, green, and blue components of the input images at the same location.
     * @param inputImages Images to be used as input
     * @param transformation the type of transformation, either 'Darker' or 'Lighter'
     * @return An image containing the lighter or darker value for each pixel in the input images
     *
     * @throws IllegalArgumentException Thrown if inputImages or any element of inputImages is null,
     * the length of the array is less than two, or  if any of the input images differ in size.
     */
    public static Image transformColorChange(Image[] inputImages, String transformation) {
        checkInputImages(inputImages);
        int width = (int) inputImages[0].getWidth();
        int height = (int) inputImages[0].getHeight();
        WritableImage image = new WritableImage(width, height);
        for(int row = 0; row &lt&#xFEFF; width; row++) {
            for(int col = 0; col &lt&#xFEFF; height; col++) {
                int[][] arr = getARGBArrays(inputImages, row, col);
                int a = calculateColorChange(arr[0], transformation);
                int r = calculateColorChange(arr[1], transformation);
                int g = calculateColorChange(arr[2], transformation);
                int b = calculateColorChange(arr[3], transformation);
                image.getPixelWriter().setArgb(row, col, argbToInt(a, r, g, b));
            }
        }
        return image;
    }

    /**
     * Reads an image in PPM, PNG, or JPG format
     * @param imagePath the path to the image to be read
     * @return An image object containing the image read from the file.
     *
     * @throws IllegalArgumentException Thrown if imagePath is null.
     * @throws IOException Thrown if the image format is invalid or
     * there was trouble reading the file.
     */
    public static Image readImage(Path imagePath) throws IOException {
        checkImagePath(imagePath);
        String path = imagePath.toString();
        if(path.length() &lt&#xFEFF; MINIMUM_FILE_LENGTH) {
            throw new IOException("Please ensure the image paths have lengths greater than 4");
        }
        String fileExtension = path.substring(path.length() - 4);
        Image image;
        if(fileExtension.equals(".ppm")) {
            image = readPPMImage(imagePath);
        } else if(fileExtension.equals(".png") || fileExtension.equals(".jpg")) {
            image = new Image(new FileInputStream(imagePath.toFile()));
        } else {
            throw new IllegalArgumentException(
                    "Please ensure the image path has extension '.ppm', '.png', or 'jpg'");
        }
        return image;
    }

    /**
     * Writes an image in PPM, PNG, or JPG format
     * @param imagePath the path to where the file should be written
     * @param image the image containing the pixels to be written to the file
     *
     * @throws IllegalArgumentException Thrown if imagePath is null.
     * @throws IOException Thrown if the image format is invalid or
     * there was trouble reading the file.
     */
    public static void writeImage(Path imagePath, Image image) throws IOException {
        checkImagePath(imagePath);
        String path = imagePath.toString();
        if(path.length() &lt&#xFEFF; MINIMUM_FILE_LENGTH) {
            throw new IOException("Please ensure the image paths have lengths greater than 4");
        }
        if(image == null) {
            throw new IllegalArgumentException("Please ensure the image is not null");
        }
        String fileExtension = path.substring(path.length() - 4);
        if(fileExtension.equals(".ppm")) {
            writePPMImage(imagePath, image);
        } else if(fileExtension.equals(".png") || fileExtension.equals(".jpg")) {
            ImageIO.write(SwingFXUtils.fromFXImage(image, null),
                    fileExtension.substring(1), imagePath.toFile());
        } else {
            throw new IllegalArgumentException(
                    "Please ensure the image path has extension '.ppm', '.png', or 'jpg'");
        }
    }

    /**
     * Reads an image in PPM format. The method only supports the plain PPM (P3)
     * format with 24-bit color and does not support comments in the image file.
     * @param imagePath the path to the image to be read
     * @return An image object containing the image read from the file.
     *
     * @throws IllegalArgumentException Thrown if imagePath is null.
     * @throws IOException Thrown if the image format is invalid or
     * there was trouble reading the file.
     */
    private static Image readPPMImage(Path imagePath) throws IOException {
        checkImagePath(imagePath);
        if(!imagePath.toString().endsWith(".ppm")) {
            throw new IOException("Please ensure the image path has extension '.ppm'");
        }
        try (Scanner reader = new Scanner(imagePath)) {
            if(!reader.next().equals("P3")) {
                throw new IOException(
                        "Invalid image format. The first non-comment line is not 'P3'");
            }
            int width = reader.nextInt();
            int height = reader.nextInt();
            WritableImage image = new WritableImage(width, height);
            if(reader.nextInt() != MAX_COLOR) {
                throw new IOException(
                        "Invalid image format. The max value was not equal to " + MAX_COLOR);
            }
            for(int col = 0; col &lt&#xFEFF; height; col++) {
                for(int row = 0; row &lt&#xFEFF; width; row++) {
                    int r = reader.nextInt();
                    int g = reader.nextInt();
                    int b = reader.nextInt();
                    int argb = argbToInt(MAX_COLOR, r, g, b);
                    image.getPixelWriter().setArgb(row, col, argb);
                }
            }
            return image;
        }
    }

    /**
     * Writes an image in PPM format. The method only supports the plain PPM (P3)
     * format with 24-bit color and does not support comments in the image file.
     * @param imagePath the path to where the file should be written
     * @param image the image containing the pixels to be written to the file
     *
     * @throws IllegalArgumentException Thrown if imagePath is null.
     * @throws IOException Thrown if the image format is invalid or
     * there was trouble reading the file.
     */
    private static void writePPMImage(Path imagePath, Image image) throws IOException {
        checkImagePath(imagePath);
        if(!imagePath.toString().endsWith(".ppm")) {
            throw new IOException("Please ensure the image path has extension '.ppm'");
        }
        try (PrintWriter writer = new PrintWriter(imagePath.toFile())) {
            int width = (int) image.getWidth();
            int height = (int) image.getHeight();
            writer.println("P3");
            writer.println(width + " " + height);
            writer.println(MAX_COLOR);
            for(int col = 0; col &lt&#xFEFF; height; col++) {
                for(int row = 0; row &lt&#xFEFF; width; row++) {
                    int argb = image.getPixelReader().getArgb(row, col);
                    int r = argbToRed(argb);
                    int g = argbToGreen(argb);
                    int b = argbToBlue(argb);
                    writer.format("%3d %3d %3d   ", r, g, b);
                }
                writer.println();
            }
        }
    }

    /**
     * Extract 8-bit Alpha value of color from 32-bit representation of the color in the format
     * described by the INT_ARGB PixelFormat type.
     * @param argb the 32-bit representation of the color
     * @return the 8-bit Alpha value of the color.
     */
    private static int argbToAlpha(int argb) {
        final int bitShift = 24;
        return argb >> bitShift;
    }

    /**
     * Extract 8-bit Red value of color from 32-bit representation of the color in the format
     * described by the INT_ARGB PixelFormat type.
     * @param argb the 32-bit representation of the color
     * @return the 8-bit Red value of the color.
     */
    private static int argbToRed(int argb) {
        final int bitShift = 16;
        final int mask = 0xff;
        return (argb >> bitShift) & mask;
    }

    /**
     * Extract 8-bit Green value of color from 32-bit representation of the color in the format
     * described by the INT_ARGB PixelFormat type.
     * @param argb the 32-bit representation of the color
     * @return the 8-bit Green value of the color.
     */
    private static int argbToGreen(int argb) {
        final int bitShift = 8;
        final int mask = 0xff;
        return (argb >> bitShift) & mask;
    }

    /**
     * Extract 8-bit Blue value of color from 32-bit representation of the color in the format
     * described by the INT_ARGB PixelFormat type.
     * @param argb the 32-bit representation of the color
     * @return the 8-bit Blue value of the color.
     */
    private static int argbToBlue(int argb) {
        final int bitShift = 0;
        final int mask = 0xff;
        return (argb >> bitShift) & mask;
    }

    /**
     * Converts argb components into a single int that represents the argb value of a color.
     * @param a the 8-bit Alpha channel value of the color
     * @param r the 8-bit Red channel value of the color
     * @param g the 8-bit Green channel value of the color
     * @param b the 8-bit Blue channel value of the color
     * @return a 32-bit representation of the color in the format
     * described by the INT_ARGB PixelFormat type.
     */
    private static int argbToInt(int a, int r, int g, int b) {
        final int alphaShift = 24;
        final int redShift = 16;
        final int greenShift = 8;
        final int mask = 0xff;
        return a &lt&#xFEFF;&lt&#xFEFF; alphaShift | ((r & mask) &lt&#xFEFF;&lt&#xFEFF; redShift) | (g & mask) &lt&#xFEFF;&lt&#xFEFF; greenShift | b & mask;
    }

    /**
     * Determines if the list of inputImages is valid
     * The list is valid if no elements in the list are null, the size of the list
     * is greater than 2, and all elements have the same widths and heights as other elements.
     * @param inputImages the list to validate
     * @throws IllegalArgumentException Thrown if there is less than 2 input images,
     * any of the input images are null, or any of the input images have different dimensions
     */
    private static void checkInputImages(Image[] inputImages) {
        StringBuilder message = new StringBuilder();
        boolean flag = false;
        if(inputImages.length &lt&#xFEFF; 2) {
            flag = true;
            message.append("Please ensure there are at least 2 input images. ");

        }
        for (Image inputImage : inputImages) {
            if (inputImage == null) {
                if(!flag) {
                    message.append("Please ensure that none of the input images are null. ");
                }
                flag = true;
            }
        }
        if(!flag) {
            int width = (int) inputImages[0].getWidth();
            int height = (int) inputImages[0].getHeight();
            for(int i = 1; i &lt&#xFEFF; inputImages.length; i++) {
                if(width != (int) inputImages[i].getWidth() ||
                        height != (int) inputImages[i].getHeight()) {
                    if(!flag) {
                        message.append(
                                "Please ensure that all input images have the same dimensions");
                    }
                    flag = true;
                }
            }
        }
        if(flag) {
            throw new IllegalArgumentException(message.toString());
        }
    }

    /**
     * Sorts the given array and returns the median
     * @param arr the given array
     * @return the median value of the array
     */
    private static int calculateMedian(int[] arr) {
        Arrays.sort(arr);
        int len = arr.length;
        int median;
        if(len % 2 == 1) {
            median = arr[len / 2];
        } else {
            median = (int) Math.round((arr[len / 2] + arr[len / 2 - 1]) / 2.0);
        }
        return median;
    }

    /**
     * Checks whether the image path is null
     * @param imagePath the image path to be checked
     * @throws IllegalArgumentException thrown if the image path is null
     */
    private static void checkImagePath(Path imagePath) {
        if(imagePath == null) {
            throw new IllegalArgumentException("Please ensure the image path is not null");
        }
    }

    /**
     * Calculates the darker or lighter pixel depending on the type of transformation
     * @param arr the array of pixels
     * @param transformation either 'Darker' or 'Lighter'
     * @return a pixel value for the darker or lighter pixel
     */
    private static int calculateColorChange(int[] arr, String transformation) {
        Arrays.sort(arr);
        int value;
        if(transformation.equals("Darker")) {
            value = arr[0];
        } else {
            value = arr[arr.length - 1];
        }
        return value;
    }
~~~~
!!! BONUS: Nice extra features
    Nice feature. This will be part of the lab 5 assignment, but
    I have called these "Max" and "Min" rather than "Lighter" and
    "Darker."

~~~~ Java

    /**
     * Gets arrays of Alpha, Red, Green, and Blue values to be used for
     * median calculations and other transformations
     * @param inputImages Images to be used as input
     * @param row the current row for the pixels
     * @param col the current column for the pixels
     * @return a 2D array containing arrays containing each Alpha, Red, Green, and Blue pixel
     * values for each image at a specified row and column.
     */
    private static int[][] getARGBArrays(Image[] inputImages, int row, int col) {
        int[] alpha = new int[inputImages.length];
        int[] red = new int[inputImages.length];
        int[] green = new int[inputImages.length];
        int[] blue = new int[inputImages.length];
        for(int i = 0; i &lt&#xFEFF; inputImages.length; i++) {
            int argb = inputImages[i].getPixelReader().getArgb(row, col);
            alpha[i] = argbToAlpha(argb);
            red[i] = argbToRed(argb);
            green[i] = argbToGreen(argb);
            blue[i] = argbToBlue(argb);
        }
        int[][] arr = new int[4][];
        arr[0] = alpha;
        arr[1] = red;
        arr[2] = green;
        arr[3] = blue;
        return arr;
    }
}

~~~~

# layout.fxml

~~~~ XML
&lt&#xFEFF;?xml version="1.0" encoding="UTF-8"?>

&lt&#xFEFF;?import javafx.scene.control.Button?>
&lt&#xFEFF;?import javafx.scene.control.Label?>
&lt&#xFEFF;?import javafx.scene.control.ScrollPane?>
&lt&#xFEFF;?import javafx.scene.image.ImageView?>
&lt&#xFEFF;?import javafx.scene.layout.HBox?>
&lt&#xFEFF;?import javafx.scene.layout.VBox?>

&lt&#xFEFF;VBox prefHeight="600.0" prefWidth="600.0" xmlns="http://javafx.com/javafx/21" xmlns:fx="http://javafx.com/fxml/1" fx:controller="woodm.Controller">
   &lt&#xFEFF;children>
      &lt&#xFEFF;ScrollPane hbarPolicy="ALWAYS" prefHeight="225.0" prefWidth="600.0" vbarPolicy="NEVER">
         &lt&#xFEFF;content>
            &lt&#xFEFF;HBox fx:id="imageContainer" prefHeight="225.0" prefWidth="600.0" />
         &lt&#xFEFF;/content>
      &lt&#xFEFF;/ScrollPane>
      &lt&#xFEFF;HBox prefHeight="25.0" prefWidth="600.0">
         &lt&#xFEFF;children>
            &lt&#xFEFF;Button mnemonicParsing="false" onAction="#inputImages" prefHeight="25.0" prefWidth="85.0" text="Add Image" />
            &lt&#xFEFF;Button mnemonicParsing="false" onAction="#calculateMeanMedian" prefHeight="25.0" prefWidth="85.0" text="Mean" />
            &lt&#xFEFF;Button mnemonicParsing="false" onAction="#calculateMeanMedian" prefHeight="25.0" prefWidth="85.0" text="Median" />
            &lt&#xFEFF;Button mnemonicParsing="false" onAction="#transformColorChange" prefHeight="25.0" prefWidth="85.0" text="Darker" />
            &lt&#xFEFF;Button mnemonicParsing="false" onAction="#transformColorChange" prefHeight="25.0" prefWidth="85.0" text="Lighter" />
            &lt&#xFEFF;Button mnemonicParsing="false" onAction="#save" prefHeight="25.0" prefWidth="85.0" text="Save as" />
            &lt&#xFEFF;Button mnemonicParsing="false" onAction="#clear" prefHeight="25.0" prefWidth="85.0" text="Clear" />
         &lt&#xFEFF;/children>
      &lt&#xFEFF;/HBox>
      &lt&#xFEFF;HBox alignment="TOP_CENTER" prefHeight="201.0" prefWidth="552.0">
         &lt&#xFEFF;children>
            &lt&#xFEFF;ImageView fx:id="finalImageView" fitHeight="300.0" fitWidth="500.0" pickOnBounds="true" preserveRatio="true" />
         &lt&#xFEFF;/children>
      &lt&#xFEFF;/HBox>
      &lt&#xFEFF;Label fx:id="messageBox" alignment="CENTER" prefHeight="50.0" prefWidth="600.0" />
   &lt&#xFEFF;/children>
&lt&#xFEFF;/VBox>

~~~~

!!! FEEDBACK: Consider disabling buttons
    It is possible to disable these buttons when it is not appropriate to call them.
    For example, you could leave the <kbd>Mean</kbd>, <kbd>Median</kbd> buttons
    disabled until at least two input images have been selected.

# Commit Log

~~~~
Thu Jan 18 00:12 "Rename-package" # woodm@msoe.edu
Thu Jan 18 08:41 "User-Input" # woodm@msoe.edu
Thu Jan 18 08:44 "User-Input" # woodm@msoe.edu
Thu Jan 18 09:49 "Read-PPM-Image" # woodm@msoe.edu
Thu Jan 18 09:50 "Read-PPM-Image" # woodm@msoe.edu
Sun Jan 21 12:11 "Read-PPM-Image" # woodm@msoe.edu
Sun Jan 21 13:20 "Write-PPM-Image" # woodm@msoe.edu
Tue Jan 23 16:34 "Lab-Completed" # woodm@msoe.edu
Tue Jan 23 16:34 "Lab-Completed" # 146870432+woodrmichael@users.noreply.github.com
Tue Jan 23 16:37 "Lab-Completed" # 146870432+woodrmichael@users.noreply.github.com
Tue Jan 23 16:38 "Lab-Completed" # 146870432+woodrmichael@users.noreply.github.com
Wed Jan 24 08:53 "Graded" # gitlab@taylor.bz
Thu Jan 25 07:52 "JavaFX-Application" # woodm@msoe.edu
Thu Jan 25 07:53 "JavaFX-Application" # 146870432+woodrmichael@users.noreply.github.com
Thu Jan 25 09:08 "JavaFX-Window" # woodm@msoe.edu
Thu Jan 25 09:27 "Jar-file" # woodm@msoe.edu
Thu Jan 25 09:34 "Jar-file" # 146870432+woodrmichael@users.noreply.github.com
Mon Jan 29 08:56 "Command-line-arguments" # woodm@msoe.edu
Mon Jan 29 08:57 "Command-line-arguments" # woodm@msoe.edu
Mon Jan 29 08:58 "Command-line-arguments" # 146870432+woodrmichael@users.noreply.github.com
Tue Jan 30 21:21 "Lab-Completed" # woodm@msoe.edu
Tue Jan 30 21:23 "Lab-Completed" # 146870432+woodrmichael@users.noreply.github.com
Tue Jan 30 21:24 "Lab-Completed" # woodm@msoe.edu
Tue Jan 30 21:26 "Lab-Completed" # woodm@msoe.edu
Tue Jan 30 21:27 "Lab-Completed" # woodm@msoe.edu
Tue Jan 30 21:31 "Lab-Completed" # woodm@msoe.edu
Tue Jan 30 21:33 "Lab-Completed" # woodm@msoe.edu
Wed Jan 31 04:23 "Graded" # gitlab@taylor.bz
Wed Jan 31 05:00 "Graded" # gitlab@taylor.bz
Wed Jan 31 23:47 "FXML-shell" # woodm@msoe.edu
Thu Feb 1 09:04 "Display-Image" # woodm@msoe.edu
Thu Feb 1 09:29 "Input-Images" # woodm@msoe.edu
Thu Feb 1 09:30 "Input-Images" # 146870432+woodrmichael@users.noreply.github.com
Thu Feb 1 09:39 "Input-Images" # 146870432+woodrmichael@users.noreply.github.com
Thu Feb 1 09:45 "Input-Images" # 146870432+woodrmichael@users.noreply.github.com
Thu Feb 1 23:23 "Lab-Completed" # woodm@msoe.edu
Thu Feb 1 23:24 "Lab-Completed" # 146870432+woodrmichael@users.noreply.github.com
Thu Feb 1 23:24 "Lab-Completed" # 146870432+woodrmichael@users.noreply.github.com
Thu Feb 1 23:24 "Lab-Completed" # woodm@msoe.edu
Thu Feb 1 23:25 "Lab-Completed" # woodm@msoe.edu
Thu Feb 1 23:34 "Lab-Completed" # woodm@msoe.edu
Sun 17:39 "Lab-Completed" # woodm@msoe.edu
~~~~

!!! MINUS: -2 Incomplete commit
    The first commit for this assignment was incomplete. Your FXML file
    did not contain the UI elements needed to support the GUI functionality
    for the lab.

<!-- Markdeep: --><script src="https://csse.msoe.us/markdeep.js?graded"></script>
