<meta charset="utf-8" lang="en">            <style class="fallback">body{visibility:hidden;}</style>
<!---


                       DOWNLOAD AND OPEN IN A BROWSER
                          TO SEE PROPER FORMATTING


--->
**Lab 1: Mean Image Median**
    Username: woodm
    Date: 01-23-2024
    Course: CSC1120
    Submitted to: Dr. Chris Taylor

!!! METRIcS: Instructor Feedback
    | Earned | Possible | Criteria                                         |
    | ------ | -------- | ------------------------------------------------ |
    |   70   |    70    | Technical quality (see point deductions in code) |
    |   15   |    15    | Intermediate commits                             |
    |   10   |    10    | Coding standard compliance and program clarity   |
    |    5   |     5    | Following submission instructions                |

    [Nicely Done](https://msoe.us/taylor/Nice)

# Lab1.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 1 - Mean Image Median
 * Name: Michael Wood
 * Created: 1/18/2024
 */
package woodm;

import mocked.Image;

import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Runs the main method to generate a mean or median image or 2 or more images.
 */
public class Lab1 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String choice;
        do {
            System.out.print("mean or median?: ");
            choice = in.nextLine().toLowerCase();
        } while(!choice.equals("mean") && !choice.equals("median"));
        System.out.print("Which file would you like to output to?: ");
        String output = in.nextLine();
        Path outputPath = Path.of(output);
        ArrayList&lt&#xFEFF;String> inputs = new ArrayList&lt&#xFEFF;>();
        System.out.println("Enter at least 2 input files: (-1 to quit)");
        String input;
        do {
            System.out.print("Input File " + (inputs.size() + 1) + ": ");
            input = in.nextLine();
            if(!input.equals("-1")) {
                inputs.add(input);
            }
        } while(!input.equals("-1"));
        Image[] inputImages = new Image[inputs.size()];
        try {
            for(int i = 0; i &lt&#xFEFF; inputs.size(); i++) {
                inputImages[i] = MeanImageMedian.readPPMImage(Path.of(inputs.get(i)));
            }
            Image finalImage = null;
            try {
                if(choice.equals("mean")) {
                    finalImage = MeanImageMedian.calculateMeanImage(inputImages);
                } else {
                    finalImage = MeanImageMedian.calculateMedianImage(inputImages);
                }
            } catch (IllegalArgumentException e) {
                if(inputImages.length &lt&#xFEFF; 2) {
                    System.out.println("Please enter at least 2 input files.");
                } else {
                    System.out.println(
                            "Please ensure that your input images have the same width and height");
                }
            }
            MeanImageMedian.writePPMImage(outputPath, finalImage);
            System.out.println("Your output image can be found at " + outputPath.toAbsolutePath());
        } catch (IllegalArgumentException e) {
            System.out.println("Please ensure that your input paths are not null.");
        } catch (IOException e) {
            System.out.println("File could not be read or file does not take the type 'ppm'.");
        }

    }
}

~~~~

# MeanImageMedian.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 1 - Mean Image Median Lab
 * Name: Michael Wood
 * Created: 1/18/2024
 */
package woodm;

import mocked.Image;
import mocked.WritableImage;

import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Scanner;


/**
 * The MeanImageMedian class offers multiple methods to generate mean and median images
 * of 2 or more images.
 */
public class MeanImageMedian {
    
    /**
     * Maximum color value
     */
    public static final int MAX_COLOR = 255;

    /**
     * Calculates the median of all the images passed to the method.
     * &lt&#xFEFF;br />
     * Each pixel in the output image consists is calculated as the median
     * red, green, and blue components of the input images at the same location.
     * @param inputImages Images to be used as input
     * @return An image containing the median color value for each pixel in the input images
     *
     * @throws IllegalArgumentException Thrown if inputImages or any element of inputImages is null,
     * the length of the array is less than two, or  if any of the input images differ in size.
     */
    public static Image calculateMedianImage(Image[] inputImages) {
        if(checkInputImages(inputImages)) {
~~~~ Java highlight
            throw new IllegalArgumentException();
~~~~
!!! MINUS: Pass useful message
    The [Coding Standard](https://csse.msoe.us/csc1120/codingstandard) requires
    the following:
    <blockquote>When possible, descriptive text is passed to the constructor
    when an exception is instantiated.</blockquote>

~~~~ Java
        }
        int width = (int) inputImages[0].getWidth();
        int height = (int) inputImages[0].getHeight();
        WritableImage image = new WritableImage(width, height);
        for(int i = 0; i &lt&#xFEFF; width; i++) {
            for(int j = 0; j &lt&#xFEFF; height; j++) {
                int[] alpha = new int[inputImages.length];
                int[] red = new int[inputImages.length];
                int[] green = new int[inputImages.length];
                int[] blue = new int[inputImages.length];
                for(int x = 0; x &lt&#xFEFF; inputImages.length; x++) {
                    int argb = inputImages[x].getPixelReader().getArgb(i, j);
                    alpha[x] = argbToAlpha(argb);
                    red[x] = argbToRed(argb);
                    green[x] = argbToGreen(argb);
                    blue[x] = argbToBlue(argb);
                }
                int a = calculateMedian(alpha);
                int r = calculateMedian(red);
                int g = calculateMedian(green);
                int b = calculateMedian(blue);
                image.getPixelWriter().setArgb(i, j, argbToInt(a, r, g, b));
            }
        }
        return image;
    }

    /**
     * Calculates the mean of all the images passed to the method.
     * &lt&#xFEFF;br />
     * Each pixel in the output image consists is calculated as the average of the
     * red, green, and blue components of the input images at the same location.
     * @param inputImages Images to be used as input
     * @return An image containing the mean color value for each pixel in the input images
     *
     * @throws IllegalArgumentException Thrown if inputImages or any element of inputImages is null,
     * the length of the array is less than two, or  if any of the input images differ in size.
     */
    public static Image calculateMeanImage(Image[] inputImages) {
        if(checkInputImages(inputImages)) {
            throw new IllegalArgumentException();
        }
        int width = (int) inputImages[0].getWidth();
        int height = (int) inputImages[0].getHeight();
        WritableImage image = new WritableImage(width, height);
        for(int i = 0; i &lt&#xFEFF; width; i++) {
            for(int j = 0; j &lt&#xFEFF; height; j++) {
                int a = 0;
                int r = 0;
                int g = 0;
                int b = 0;
                for(int x = 0; x &lt&#xFEFF; inputImages.length; x++) {
                    int argb = inputImages[x].getPixelReader().getArgb(i, j);
                    a += argbToAlpha(argb);
                    r += argbToRed(argb);
                    g += argbToGreen(argb);
                    b += argbToBlue(argb);
                }
                a = (int) Math.round(((double) a) / inputImages.length);
                r = (int) Math.round(((double) r) / inputImages.length);
                g = (int) Math.round(((double) g) / inputImages.length);
                b = (int) Math.round(((double) b) / inputImages.length);
                image.getPixelWriter().setArgb(i, j, argbToInt(a, r, g, b));
            }
        }
        return image;
    }

    /**
     * Reads an image in PPM format. The method only supports the plain PPM (P3)
     * format with 24-bit color and does not support comments in the image file.
     * @param imagePath the path to the image to be read
     * @return An image object containing the image read from the file.
     *
     * @throws IllegalArgumentException Thrown if imagePath is null.
     * @throws IOException Thrown if the image format is invalid or
     * there was trouble reading the file.
     */
    public static Image readPPMImage(Path imagePath) throws IOException {
        if(imagePath == null) {
            throw new IllegalArgumentException();
        }
        if(!imagePath.toString().endsWith(".ppm")) {
            throw new IOException();
        }
        try (Scanner reader = new Scanner(imagePath)) {
~~~~ Java highlight
            reader.next();
~~~~
!!! MINUS: -1 Must verify that file starts with P3
    The assignment stated:
    <blockquote>The first non-comment line must begin with <kbd>P3</kbd>
    followed by whitespace (typically a new line)</blockquote>

    This method should throw an `IOException` (as noted in the Javadoc
    above) if the file format is invalid.

~~~~ Java
            int width = reader.nextInt();
            int height = reader.nextInt();
            WritableImage image = new WritableImage(width, height);
~~~~ Java highlight
            reader.nextInt();
~~~~
!!! MINUS: -1 Must verify that MAXVALUE is 255
    The assignment stated:
    <blockquote>An integer specifying the MAXVALUE is next (for this
    lab, the value must be 255), followed by whitespace</blockquote>

    This method should throw an `IOException` (as noted in the Javadoc
    above) if the file format is invalid.

~~~~ Java
            for(int j = 0; j &lt&#xFEFF; height; j++) {
                for(int i = 0; i &lt&#xFEFF; width; i++) {
                    int r = reader.nextInt();
                    int g = reader.nextInt();
                    int b = reader.nextInt();
                    int argb = argbToInt(MAX_COLOR, r, g, b);
                    image.getPixelWriter().setArgb(i, j, argb);
                }
            }
            return image;
        }
    }

    /**
     * Writes an image in PPM format. The method only supports the plain PPM (P3)
     * format with 24-bit color and does not support comments in the image file.
     * @param imagePath the path to where the file should be written
     * @param image the image containing the pixels to be written to the file
     *
     * @throws IllegalArgumentException Thrown if imagePath is null.
     * @throws IOException Thrown if the image format is invalid or
     * there was trouble reading the file.
     */
    public static void writePPMImage(Path imagePath, Image image) throws IOException {
        if(imagePath == null) {
            throw new IllegalArgumentException();
        }
        if(!imagePath.toString().endsWith(".ppm")) {
            throw new IOException();
        }
        try (PrintWriter writer = new PrintWriter(imagePath.toFile())) {
            int width = (int) image.getWidth();
            int height = (int) image.getHeight();
            writer.println("P3");
            writer.println(width + " " + height);
            writer.println(MAX_COLOR);
~~~~ Java highlight
            for(int j = 0; j &lt&#xFEFF; height; j++) {
                for(int i = 0; i &lt&#xFEFF; width; i++) {
~~~~
!!! MINUS: Meaningful names
    Here you could use `x` and `y` or `row` and `col` for names of your
    loop variables so that convey more information about what they represent.

~~~~ Java
                    int argb = image.getPixelReader().getArgb(i, j);
                    int r = argbToRed(argb);
                    int g = argbToGreen(argb);
                    int b = argbToBlue(argb);
                    writer.format("%3d %3d %3d   ", r, g, b);
                }
                writer.println();
            }
        }
    }

    /**
     * Extract 8-bit Alpha value of color from 32-bit representation of the color in the format
     * described by the INT_ARGB PixelFormat type.
     * @param argb the 32-bit representation of the color
     * @return the 8-bit Alpha value of the color.
     */
    private static int argbToAlpha(int argb) {
        final int bitShift = 24;
        return argb >> bitShift;
    }

    /**
     * Extract 8-bit Red value of color from 32-bit representation of the color in the format
     * described by the INT_ARGB PixelFormat type.
     * @param argb the 32-bit representation of the color
     * @return the 8-bit Red value of the color.
     */
    private static int argbToRed(int argb) {
        final int bitShift = 16;
        final int mask = 0xff;
        return (argb >> bitShift) & mask;
    }

    /**
     * Extract 8-bit Green value of color from 32-bit representation of the color in the format
     * described by the INT_ARGB PixelFormat type.
     * @param argb the 32-bit representation of the color
     * @return the 8-bit Green value of the color.
     */
    private static int argbToGreen(int argb) {
        final int bitShift = 8;
        final int mask = 0xff;
        return (argb >> bitShift) & mask;
    }

    /**
     * Extract 8-bit Blue value of color from 32-bit representation of the color in the format
     * described by the INT_ARGB PixelFormat type.
     * @param argb the 32-bit representation of the color
     * @return the 8-bit Blue value of the color.
     */
    private static int argbToBlue(int argb) {
        final int bitShift = 0;
        final int mask = 0xff;
        return (argb >> bitShift) & mask;
    }

    /**
     * Converts argb components into a single int that represents the argb value of a color.
     * @param a the 8-bit Alpha channel value of the color
     * @param r the 8-bit Red channel value of the color
     * @param g the 8-bit Green channel value of the color
     * @param b the 8-bit Blue channel value of the color
     * @return a 32-bit representation of the color in the format
     * described by the INT_ARGB PixelFormat type.
     */
    private static int argbToInt(int a, int r, int g, int b) {
        final int alphaShift = 24;
        final int redShift = 16;
        final int greenShift = 8;
        final int mask = 0xff;
        return a &lt&#xFEFF;&lt&#xFEFF; alphaShift | ((r & mask) &lt&#xFEFF;&lt&#xFEFF; redShift) | (g & mask) &lt&#xFEFF;&lt&#xFEFF; greenShift | b & mask;
    }

    /**
     * Determines if the list of inputImages is valid
     * The list is valid if no elements in the list are null, the size of the list
     * is greater than 2, and all elements have the same widths and heights as other elements.
     * @param inputImages the list to validate
     * @return false if valid, true if invalid
     */
    private static boolean checkInputImages(Image[] inputImages) {
        if(inputImages.length &lt&#xFEFF; 2) {
~~~~ Java highlight
            return true;
~~~~
        }
        for(int i = 0; i &lt&#xFEFF; inputImages.length; i++) {
            if(inputImages[i] == null) {
~~~~ Java highlight
                return true;
~~~~
            }
        }
        int width = (int) inputImages[0].getWidth();
        int height = (int) inputImages[0].getHeight();
        for(int i = 1; i &lt&#xFEFF; inputImages.length; i++) {
            if(width != (int) inputImages[i].getWidth() ||
                    height != (int) inputImages[i].getHeight()) {
~~~~ Java highlight
                return true;
~~~~
            }
        }
~~~~ Java highlight
        return false;
~~~~
!!! FEEDBACK: Avoid multiple return statements
    You should avoid using multiple `return` statements within a method.
    Doing so tends to make your code harder to understand and maintain.

    There are times when it may make sense to have multiple returns in one
    method, but I want you to be able to think through how you could implement
    a method so that it has only one exit point.  As a result, this term I
    will be taking points off when students submit code that has multiple
    return statements in a single method.

~~~~ Java
    }

    /**
     * Sorts the given array and returns the median
     * @param arr the given array
     * @return the median value of the array
     */
    private static int calculateMedian(int[] arr) {
        Arrays.sort(arr);
        int len = arr.length;
        if(len % 2 == 1) {
            return arr[len / 2];
        }
        return (int) Math.round((arr[len / 2] + arr[len / 2 - 1]) / 2.0);
    }
}

~~~~

# Commit Log

~~~~
Thu Jan 18 00:12 "Rename-package" # woodm@msoe.edu
Thu Jan 18 08:41 "User-Input" # woodm@msoe.edu
Thu Jan 18 08:44 "User-Input" # woodm@msoe.edu
Thu Jan 18 09:49 "Read-PPM-Image" # woodm@msoe.edu
Thu Jan 18 09:50 "Read-PPM-Image" # woodm@msoe.edu
Sun 12:11 "Read-PPM-Image" # woodm@msoe.edu
Sun 13:20 "Write-PPM-Image" # woodm@msoe.edu
Tue 16:34 "Lab-Completed" # woodm@msoe.edu
~~~~

## Instructor Tests

### Tests for `readPPMImage()` with valid images
- &#x02714; Correctly read images/a.ppm.
- &#x02714; Correctly read images/b.ppm.
- &#x02714; Correctly read images/c.ppm.

### Tests for `readPPMImage()` with invalid images
- &#x0274C; Incorrectly reads invalid images/d.ppm.
- &#x0274C; Incorrectly reads invalid images/e.ppm.
- &#x02714; Correctly throws an exception when attempting to read images/f.ppm.

### Tests for `writePPMImage()`
- &#x02714; Correctly writes images/a.ppm.

### Tests for `calculateMeanImage()`
- &#x02714; Correctly calculates the mean image of images/1.ppm, images/2.ppm, images/3.ppm.

### Tests for `calculateMedianImage()`
- &#x02714; Correctly calculates the median image of images/1.ppm, images/2.ppm, images/3.ppm.


## Images used for mean and median calculations

- images/1.ppm
~~~
images/1.ppm          images/2.ppm          images/3.ppm
P3                    P3                    P3
1 3                   1 3                   1 3
255                   255                   255
255 255 255             0   0   0           255   0   0
255 255 255             0   0   0             0 255   0
255 255 255             0   0   0             0   0 255
~~~

## Images used valid `readPPMImage()` test

- images/a.ppm
~~~
P3
1 3
255
255 255 255
255 255 255
255 255 255
~~~

- images/b.ppm
~~~
P3
1 3
255
  0   0   0     0   0   0     0   0   0
~~~

- images/c.ppm
~~~
P3 1 3 255 255 0 0 0 255 0 0 0 255
~~~

## Images used for invalid `readPPMImage()` test

~~~
images/d.ppm          images/e.ppm          images/f.ppm
P1                    P3                    P3
1 3                   1 3                   1 3
255                   100                   255
255   0   0           255   0   0           255   0   0
  0 255   0             0 255   0             0 255   0
  0   0 255             0   0 255             0
~~~

<!-- Markdeep: --><script src="https://csse.msoe.us/markdeep.js?graded"></script>
